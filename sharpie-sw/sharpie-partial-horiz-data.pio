.pio_version 1

.program sharpie_partial_horiz_data
.side_set 2

; side-set: BCK and BSP
;           bit 1   bit 0

; each instruction is 166 ns (1/4 of a BCK cycle)

; counter in x is the inner data loop, counter in y is the outer total loop

; DMA stream needs to look like:
; - outer counter loop (8 bits)
; - bytes of data
;
; ISR must also be charged to 59 before this state machine ever starts running

.wrap_target

; wait for GCK rise from PIO 1

wait 1 irq next 2 side 0b00

; we can't tamper with any of the delays beneath the `restart:` label, because
; then the loop is broken (past the first time, at best, and always, at worst)

restart:
mov x, isr        side 0b01 [1] ; BSP rises 333 ns after GCK1 rises and charge X for this loop
pull              side 0b11 [1] ; BCK1 rises 333 ns after BSP rises, and get the outer loop counter
out pins, 8       side 0b11 [1] ; hold BCK1, BSP still high, set data out
nop               side 0b01 [1] ; fall BCK1, BSP still high

loop:
out pins, 8       side 0b00     ; fall BSP, next data out, middle of BCK2
jmp !x, exit      side 0b00     ; exit the loop if it's the last iteration (data goes to 0 on BCK121)
nop               side 0b10 [1] ; rise BCK
out pins, 8       side 0b10 [1] ; hold BCK, data out
jmp x--, loop     side 0b00 [1] ; fall BCK, jump

exit:
nop               side 0b10 [1] ; rise BCK121
mov pins, null    side 0b10 [1] ; set data pins to zero
nop               side 0b00 [3] ; fall BCK122 and hold for all of 122
nop               side 0b10 [3] ; rise BCK123
jmp y--, restart  side 0b00 [1] ; fall BCK124, reach middle, restart

out y, 16         side 0b00     ; load next outer counter into y (16 bits is needed because 320 lines)
.wrap


% c-sdk {
#include "hardware/gpio.h"
static inline void sharpie_partial_horiz_data_pio_init(PIO pio, uint sm, uint offset, uint bsp_pin, uint r0_pin) {
  pio_gpio_init(pio, bsp_pin); // BSP on PIO
  pio_gpio_init(pio, bsp_pin + 1); // BCK on PIO

  for (int i = 0; i < 6; i++) {
    pio_gpio_init(pio, r0_pin + i); // all color data pins on PIO
  }

  pio_sm_set_consecutive_pindirs(pio, sm, bsp_pin, 2, true); // BCK and BSP as output
  pio_sm_set_consecutive_pindirs(pio, sm, r0_pin, 6, true); // color data pins as output

  pio_sm_config c = sharpie_partial_horiz_data_program_get_default_config(offset);

  // BCK, BSP are side-set pins
  sm_config_set_sideset_pins(&c, bsp_pin);
  sm_config_set_out_pins(&c, r0_pin, 6);
  sm_config_set_out_shift(&c, true, true, 32); // shift right, autopull enabled, autopull threshold 32 bits (entire OSR has been shifted out)
  sm_config_set_clkdiv(&c, 25); // 150 MHz / 25 = 6 MHz => T = 166.66666... ns

  pio_sm_init(pio, sm, offset, &c);
  pio_sm_set_enabled(pio, sm, true);

}

%}